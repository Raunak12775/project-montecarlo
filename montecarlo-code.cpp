// Metropolis-Hastings Algorithm - Simulated Annealing

#include <iostream>
#include <fstream>
#include <vector>
#include <Eigen>
#include <cstdlib>     /* srand, rand */
#include <ctime>       /* time */
#include <cmath>
#include <sstream>
#include <utility>
#include <string>
#include <random>

using namespace std;
using namespace Eigen;
double en_old, en_new;
double T = 600; // temperature
double k = 0.001; // boltzmann constant
int maxstep = 650;
double r_cutoff = 1.20;//put rcutoff here


// random number generator -- you get different random numbers in a single compilation
double random_gen() {
    double rand_number;
    std::random_device rd;  // Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<> dis(-1.0, 1.0);
    // Use dis to transform the random unsigned int generated by gen into a
    // double in [1, 2). Each call to dis(gen) generates a new random double
    rand_number = dis(gen);
    return rand_number;
}

// Function for acceptance of the energies
bool acceptance() {
    bool accept;
    double ff = random_gen();
    if (ff < 0.0)
        ff = -ff;
    double acceptance_parameter;
    acceptance_parameter = std::min(1.0, exp((-(en_new - en_old)) / (k * T)));
    cout << "P = " << acceptance_parameter << " and ff = " << ff << endl;
    if (acceptance_parameter > ff) {
        accept = true;
        cout << "\n ACCEPTED \n";
    } else {
        accept = false;
        cout << "\n DISCARDED \n";
    }
    return accept;
}


//define class ATOM
class ATOM {
public:
    Vector3d coords;
    string elementname;

    ATOM() {};

    ATOM(double q1, double q2, double q3) {
        coords[0] = q1;
        coords[1] = q2;
        coords[2] = q3;
    }

    void print() {
        cout << " " << coords[0] << " " << coords[1] << " " << coords[2] << " " << endl;
    }


};

class molecule {
public:
    vector<ATOM> atoms;

    molecule() {};

    void add_atoms(ATOM ATOM) {
        atoms.push_back(ATOM);
    }

    long natoms() {
        return atoms.size();
    }

    void print() {
        cout << "the molecule has " << atoms.size() << " atoms " << endl;
        for (int i = 0; i < atoms.size(); ++i) {
            atoms[i].print();
        }
    }


    //Make input file; in accordance to znemo input file
    void makeinputfile() {
        ofstream input;
        input.open("input");
        input << "complex" << endl;
        input << " physical_b -5.0" << endl; //magnetic field strength
        input << "end" << endl;
        input << "\n";
        input << "dft" << endl;
        input << "k 9" << endl;
        input << "econv 1.e-5" << endl;
        input << " L 20" << endl;
        input << "end" << endl;
        input << "\n";
        input << "geometry" << endl;
        input << " no_orient 1" << endl;
        for (int i = 0; i < atoms.size(); i++) {
            input << " " << atoms[i].elementname << " " << atoms[i].coords[0] << " "
                  << atoms[i].coords[1] << " " << atoms[i].coords[2] << endl;
        }
        input << "end";
        input.close();
    }


    // Variating the coordinates
    void variate() {
        for (int iatom = 0; iatom < atoms.size(); ++iatom) {
            atoms[iatom].coords[0] += 0.1 * random_gen();
            atoms[iatom].coords[1] += 0.1 * random_gen();
            atoms[iatom].coords[2] += 0.1 * random_gen();
        }
    }

    //get bondlength
    double bondlength(ATOM &atom1, ATOM &atom2) {
        double length = 0.0;
        double r_squared = 0.0;
        r_squared = pow((atom1.coords[0] - atom2.coords[0]), 2.0) + pow((atom1.coords[1] - atom2.coords[1]), 2.0) +
                    pow((atom1.coords[2] - atom2.coords[2]), 2.0);
        length = pow(r_squared, 0.5);
        return length;
    }

    // database for all possible combination of bondlengths
    vector<double> data_lengths() {
        vector<double> data;
        for (int i = 0; i < atoms.size(); ++i) {
            double cbl = 1000.0;
            for (int j = 0; j < atoms.size(); ++j) {
                if (i == j) { continue; }
                else if (bondlength(atoms[i], atoms[j]) < cbl) {
                    cbl = bondlength(atoms[i], atoms[j]);
                 
                }
            }
		data.push_back(cbl);
        }
        return data;
    }

    //additional potential
    double bias_potential() {
        double bp = 0.0;
        for (int k = 0; k < data_lengths().size(); ++k) {
            for (int i = 0; i < atoms.size(); ++i) {
                for (int j = i + 1; j < atoms.size(); ++j) {
                    if (data_lengths()[k] < r_cutoff) {
                        bp += 0.0;
                    } else {
                        bp += pow((bondlength(atoms[i], atoms[j]) - r_cutoff), 2.0);
                    }
                }
            }
        }
        return bp;
    }

    //Calculating energy
    double znemo_energy() {

        makeinputfile();
        std::system("module load MADNESS/znemo; znemo > znemo.out"); // execute the UNIX command "ls -l >test.txt"


        double energy;
        std::string filename = "znemo.out";
        std::ifstream ifile(filename.c_str());
        std::string line;
        while (getline(ifile, line)) {
            std::string word1, word2;
            std::stringstream sline(line);
            sline >> word1 >> word2;
            if (word1 == "final" && word2 == "energy") sline >> energy;
        }
        return energy;

    }
    }; // end of molecule class


    int main() {
        int nacc, nrej;
        static auto seed = time(NULL);
        srand(seed);
        molecule new_molecule, old_molecule;

        int natoms;
        ifstream infile("input.xyz");
        infile >> natoms;
        for (int i = 0; i < natoms; i++) {
            double q1, q2, q3;
            string element;
            infile >> element >> q1 >> q2 >> q3;
            ATOM ATOM;
            ATOM.elementname = element;
            ATOM.coords[0] = q1;
            ATOM.coords[1] = q2;
            ATOM.coords[2] = q3;
            cout << "Coordinates of atom " << ATOM.elementname << " " << ATOM.coords[0] << " " << ATOM.coords[1]
                 << " " << ATOM.coords[2] << endl;
            new_molecule.add_atoms(ATOM);
            old_molecule.add_atoms(ATOM);
        }

        ofstream output;
        ofstream geom;
        geom.open("geometries.txt");
        output.open("output.txt");

        en_old = old_molecule.znemo_energy() + old_molecule.bias_potential();
            if (old_molecule.bias_potential() != 0.0){cout << "Bias added" << endl;}

       
	 for (int steps = 0; steps < maxstep; steps++) {
            T = T * 0.99; // slowing the decay of the T
            cout << "\n";
            cout << "*****************************Iteration - " << steps
                 << "********************************************"
                 << endl;
            cout << "T = " << T << endl;

            new_molecule.variate();

            en_new = new_molecule.znemo_energy() + new_molecule.bias_potential();
            if (new_molecule.bias_potential() != 0.0){cout << "Bias added" << endl;}

            bool correct = acceptance();
            if (correct == true) {
                nacc++;
                cout << "\nThe energy of the old coordinates are : " << en_old << endl;;
                en_old = en_new;
                old_molecule = new_molecule;
                cout << "\nThe energy of the new coordinates are : " << en_new << endl;;

                // prints out the energies corresponding to the T values for plotting purpose
                output << T << "       " << en_new << endl;

                // prints out the geometry in a separate file
                geom << "\n";
                geom << "The coordinates for the accepted iteration : " << steps << endl;
                geom << natoms << endl;
                geom << "Energy = " << en_new << endl;
                for (int i = 0; i < new_molecule.atoms.size(); i++) {
                    geom << new_molecule.atoms[i].elementname << " " << new_molecule.atoms[i].coords[0] << " "
                         << new_molecule.atoms[i].coords[1] << " " << new_molecule.atoms[i].coords[2] << endl;
                }
            } else {
                nrej++;
                new_molecule = old_molecule;
            }
            cout << "****************************************************************************************" << endl;
            cout << "\n";
            T = std::max(1.e-3, T);
        }

        geom << "The number of accepted steps : " << nacc << endl;
        geom << "The number of rejected steps : " << nrej << endl;
        output.close();
        geom.close();

        cout << "Number of accepted steps: " << nacc << endl;
        cout << "Number of rejected steps: " << nrej << endl;

        cout << "Job Done!" << endl;
        return 0;
    }


